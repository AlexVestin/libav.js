<!doctype html>
<html>
    <head>
        <title>LibAV demuxing-simple</title>
    </head>
    <body>
        <script type="text/javascript">LibAV = {base:".."}</script>
        <script type="text/javascript" src="../libav-1.4.1-default.js"></script>
        <script type="text/javascript" src="exa.opus.js"></script>
        <script type="text/javascript">
            // This is a loose port of doc/examples/demuxing_decoding.c, simplified
            function main() {
                var libav = LibAV;
                var fmt_ctx, streams, audio_stream_idx, pkt, frame, codec, c;

                new Promise(function(res, rej) {
                    var xhr = new XMLHttpRequest();
                    xhr.responseType = "arraybuffer";
                    xhr.open("GET", "exa.opus", true);

                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200)
                                res(xhr.response);
                            else
                                rej(xhr.status);
                        }
                    };

                    xhr.send();

                }).then(function(ret) {
                    return libav.writeFile("tmp.opus", new Uint8Array(ret));

                }).then(function() {
                    ta = performance.now();
                    return libav.ff_init_demuxer_file("tmp.opus");

                }).then(function(ret) {
                    fmt_ctx = ret[0];
                    streams = ret[1];

                    var si, stream;
                    for (si = 0; si < streams.length; si++) {
                        stream = streams[si];
                        if (stream.codec_type === libav.AVMEDIA_TYPE_AUDIO)
                            break;
                    }
                    if (si >= streams.length)
                        throw new Error("Couldn't find audio stream");

                    audio_stream_idx = stream.index;
                    return libav.ff_init_decoder(stream.codec_id);

                }).then(function(ret) {
                    c = ret[1];
                    pkt = ret[2];
                    frame = ret[3];

                    return libav.ff_read_multi(fmt_ctx, pkt);

                }).then(function(ret) {
                    if (ret[0] !== libav.AVERROR_EOF)
                        throw new Error("Error reading: " + ret[0]);

                    return libav.ff_decode_multi(c, pkt, frame, ret[1], true);

                }).then(function(ret) {
                    var div = document.createElement("pre");
                    div.innerText = "[\n" + ret.map(function(pkt) {
                        return "new Uint8Array([" + Array.prototype.join.call(pkt.data, ", ") + "])";
                    }).join(",\n") + "\n]";
                    document.body.appendChild(div);

                    return Promise.all([
                        libav.ff_free_decoder(c, pkt, frame),
                        libav.avformat_close_input_js(fmt_ctx)
                    ]);

                }).then(function() {
                    // Nothing

                }).catch(function(err) {
                    alert(err);
                });
            }

            if (LibAV.ready) {
                main();
            } else {
                LibAV.onready = main;
            }
        </script>
    </body>
</html>
